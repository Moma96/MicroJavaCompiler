package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import org.apache.log4j.*;
import rs.ac.bg.etf.pp1.ast.*;


parser code {:

	boolean errorDetected;
	
	Logger log = Logger.getLogger(getClass());
	
	public void report_fatal_error(String message, Object info) throws java.lang.Exception {
		done_parsing();
		report_error(message, info);
	}
	
	public void syntax_error(Symbol cur_token) {
		report_error("\nSyntax error", cur_token);
	}
	
	public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
		report_fatal_error("Fatal error: parsing must be terminated", cur_token);
	}
	
	public void report_error(String message, Object info) {
		errorDetected = true;
		StringBuilder msg = new StringBuilder(message);
		if (info instanceof Symbol)
			msg.append(" in line ").append(((Symbol)info).left);
		log.error(msg.toString());
	}
	
:}

init with {:
	errorDetected = false;
:}

terminal PROGRAM, LBRACE, RBRACE, SEMI, LPAREN, RPAREN, COMMA, EQUALS, RETURN, PLUS, PRINT, VOID;
/* only for lexer: */
terminal IF, ELSE, BREAK, CLASS, WHILE, NEW, READ, CONST, EXTENDS, CONTINUE, FOREACH, MINUS, MUL, DIV, MOD, EQ, NEQ, G, GEQ, L, LEQ, AND, OR, UPLUS, UMINUS, COLON, DOT, LBRACKET, RBRACKET, ARROW;
terminal Integer BOOL;
terminal Character CHAR;
terminal Integer NUM;
terminal String IDENT;

nonterminal MethodDeclList MethodDeclList;
nonterminal ConstDeclList ConstDeclList;
nonterminal ConstDecl ConstDecl;
nonterminal ConstAssignmentList ConstAssignmentList;
nonterminal VarDeclList VarDeclList;
nonterminal VarDecl VarDecl;
nonterminal VarDeclNameList VarDeclNameList;
nonterminal StatementList StatementList;
nonterminal Assignop Assignop;
nonterminal Statement Statement;
nonterminal PrintParam PrintParam;

nonterminal rs.etf.pp1.symboltable.concepts.Obj Program, ProgramName, MethodDecl, VarDeclName, ConstAssignment, MethodTypeName, Designator;
nonterminal rs.etf.pp1.symboltable.concepts.Struct Type, Term, Factor, Const;

Program ::= (Program) PROGRAM ProgramName:P1 ConstDeclList:C2 VarDeclList:V3 LBRACE MethodDeclList:M4 RBRACE {: RESULT=new Program(P1, C2, V3, M4); RESULT.setLine(P1left); :};

ProgramName ::= (ProgramName) IDENT:name {: RESULT=new ProgramName(name); RESULT.setLine(nameleft); :};


ConstDeclList ::= (ConstDeclarations) ConstDeclList:C1 ConstDecl:C2 {: RESULT=new ConstDeclarations(C1, C2); RESULT.setLine(C1left); :} 
			|
			(NoConstDeclaration) {: RESULT=new NoConstDeclaration(); :} /* epsilon */
			;

ConstDecl ::= (ConstDecl) CONST Type:varType ConstAssignmentList:constAssignments SEMI {: RESULT=new ConstDecl(varType, constAssignments); RESULT.setLine(varTypeleft); :};

ConstAssignmentList ::= (ConstAssignments) ConstAssignmentList:C1 COMMA ConstAssignment:C2 {: RESULT=new ConstAssignments(C1, C2); RESULT.setLine(C1left); :}
					|
					(OneConstAssignment) ConstAssignment:C1 {: RESULT=new OneConstAssignment(C1); RESULT.setLine(C1left); :}
					;

ConstAssignment ::= (ConstAssignment) IDENT:constName EQUALS Const:c {: RESULT=new ConstAssignment(constName, c); RESULT.setLine(constNameleft); :};


VarDeclList ::= (VarDeclarations) VarDeclList:V1 VarDecl:V2 {: RESULT=new VarDeclarations(V1, V2); RESULT.setLine(V1left); :} 
			|
			(NoVarDeclaration) {: RESULT=new NoVarDeclaration(); :} /* epsilon */
			;

VarDecl ::= (VarDecl) Type:varType VarDeclNameList:varNames SEMI {: RESULT=new VarDecl(varType, varNames); RESULT.setLine(varTypeleft); :};

VarDeclNameList ::= (VarDeclNames) VarDeclNameList:V1 COMMA VarDeclName:V2 {: RESULT=new VarDeclNames(V1, V2); RESULT.setLine(V1left); :}
					|
					(OneVarDeclName) VarDeclName:V1 {: RESULT=new OneVarDeclName(V1); RESULT.setLine(V1left); :}
					;

VarDeclName ::= (VarDeclName) IDENT:varName {: RESULT=new VarDeclName(varName); RESULT.setLine(varNameleft); :};				


MethodDeclList ::= (MethodDeclarations) MethodDeclList:M1 MethodDecl:M2 {: RESULT=new MethodDeclarations(M1, M2); RESULT.setLine(M1left); :}
				|
				(NoMethodDeclarations) {: RESULT=new NoMethodDeclarations(); :} /* epsilon */
				;
			
MethodDecl ::= (MethodDecl) VOID MethodTypeName:M1 LPAREN RPAREN VarDeclList:V2 LBRACE StatementList:S3 RBRACE {: RESULT=new MethodDecl(M1, V2, S3); RESULT.setLine(M1left); :};

MethodTypeName ::= (MethodTypeName) IDENT:methName {: RESULT=new MethodTypeName(methName); RESULT.setLine(methNameleft); :};


StatementList ::= (Statements) StatementList:S1 Statement:S2 {: RESULT=new Statements(S1, S2); RESULT.setLine(S1left); :}
				|
				(NoStatement) {: RESULT=new NoStatement(); :} /* epsilon */
				;

Statement ::= (ErrorStatement) error SEMI:k
			{: parser.report_error("Error recovery until ; in line " + kleft, null); :} {: RESULT=new ErrorStatement(); :}
			|
			(Assignment) Designator:destination EQUALS Factor:source SEMI {: RESULT=new Assignment(destination, source); RESULT.setLine(destinationleft); :}
			|
			(PrintStatement) PRINT LPAREN Factor:F1 PrintParam:P2 RPAREN SEMI {: RESULT=new PrintStatement(F1, P2); RESULT.setLine(F1left); :}
			;

Factor ::= (Var) Designator:d {: RESULT=new Var(d); RESULT.setLine(dleft); :}
			|
			(ConstValue) Const:c {: RESULT=new ConstValue(c); RESULT.setLine(cleft); :}
			;

Designator ::= (Designator) IDENT:name {: RESULT=new Designator(name); RESULT.setLine(nameleft); :};

PrintParam ::= (PrintWidth) COMMA NUM:num {: RESULT=new PrintWidth(num); RESULT.setLine(numleft); :}
			|
			(NoPrintWidth) {: RESULT=new NoPrintWidth(); :} /* epsilon */
			;

Const ::= (NumConst) NUM:N1 {: RESULT=new NumConst(N1); RESULT.setLine(N1left); :}
		|
		(CharConst) CHAR:C1 {: RESULT=new CharConst(C1); RESULT.setLine(C1left); :}
		|
		(BoolConst) BOOL:B1 {: RESULT=new BoolConst(B1); RESULT.setLine(B1left); :}
		;

Type ::= (Type) IDENT:typeName {: RESULT=new Type(typeName); RESULT.setLine(typeNameleft); :};