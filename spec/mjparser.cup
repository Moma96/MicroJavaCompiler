package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import org.apache.log4j.*;
import rs.ac.bg.etf.pp1.ast.*;


parser code {:

	boolean errorDetected;
	
	Logger log = Logger.getLogger(getClass());
	
	public void report_fatal_error(String message, Object info) throws java.lang.Exception {
		done_parsing();
		report_error(message, info);
	}
	
	public void syntax_error(Symbol cur_token) {
		report_error("\nSyntax error", cur_token);
	}
	
	public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
		report_fatal_error("Fatal error: parsing must be terminated", cur_token);
	}
	
	public void report_error(String message, Object info) {
		errorDetected = true;
		StringBuilder msg = new StringBuilder(message);
		if (info instanceof Symbol)
			msg.append(" in line ").append(((Symbol)info).left);
		log.error(msg.toString());
	}
	
:}

init with {:
	errorDetected = false;
:}

terminal PROGRAM, LBRACE, RBRACE, SEMI, LPAREN, RPAREN, COMMA, EQUALS, RETURN, PLUS, PRINT, VOID;
/* only for lexer: */
terminal IF, ELSE, BREAK, CLASS, WHILE, NEW, READ, CONST, EXTENDS, CONTINUE, FOREACH, MINUS, MUL, DIV, MOD, EQ, NEQ, G, GEQ, L, LEQ, AND, OR, UPLUS, UMINUS, COLON, DOT, LBRACKET, RBRACKET, ARROW;
terminal Integer BOOL;
terminal Character CHAR;
terminal Integer NUM;
terminal String IDENT;

nonterminal MethodDeclList, ConstDeclList, ConstDecl, ConstAssignmentList, VarDeclList, VarDecl, VarDeclNameList, StatementList, Assignop, Statement, PrintParam;

nonterminal rs.etf.pp1.symboltable.concepts.Obj Program, ProgramName, MethodDecl, VarDeclName, ConstAssignment, MethodTypeName, Designator;
nonterminal rs.etf.pp1.symboltable.concepts.Struct Type, Term, Factor, Const;

Program ::= (Program) PROGRAM ProgramName ConstDeclList VarDeclList LBRACE MethodDeclList RBRACE;

ProgramName ::= (ProgramName) IDENT:name;


ConstDeclList ::= (ConstDeclarations) ConstDeclList ConstDecl 
			|
			(NoConstDeclaration) /* epsilon */
			;

ConstDecl ::= (ConstDecl) CONST Type:varType ConstAssignmentList:constAssignments SEMI;

ConstAssignmentList ::= (ConstAssignments) ConstAssignmentList COMMA ConstAssignment
					|
					(OneConstAssignment) ConstAssignment
					;

ConstAssignment ::= (ConstAssignment) IDENT:constName EQUALS Const:c;


VarDeclList ::= (VarDeclarations) VarDeclList VarDecl 
			|
			(NoVarDeclaration) /* epsilon */
			;

VarDecl ::= (VarDecl) Type:varType VarDeclNameList:varNames SEMI;

VarDeclNameList ::= (VarDeclNames) VarDeclNameList COMMA VarDeclName
					|
					(OneVarDeclName) VarDeclName
					;

VarDeclName ::= (VarDeclName) IDENT:varName;				


MethodDeclList ::= (MethodDeclarations) MethodDeclList MethodDecl
				|
				(NoMethodDeclarations) /* epsilon */
				;
			
MethodDecl ::= (MethodDecl) VOID MethodTypeName LPAREN RPAREN VarDeclList LBRACE StatementList RBRACE;

MethodTypeName ::= (MethodTypeName) IDENT:methName;


StatementList ::= (Statements) StatementList Statement
				|
				(NoStatement) /* epsilon */
				;

Statement ::= (ErrorStatement) error SEMI:k
			{: parser.report_error("Error recovery until ; in line " + kleft, null); :}
			|
			(Assignment) Designator:destination EQUALS Factor:source SEMI
			|
			(PrintStatement) PRINT LPAREN Factor PrintParam RPAREN SEMI
			;

Factor ::= (Var) Designator:d
			|
			(ConstValue) Const:c
			;

Designator ::= (Designator) IDENT:name;

PrintParam ::= (PrintWidth) COMMA NUM:num
			|
			(NoPrintWidth) /* epsilon */
			;

Const ::= (NumConst) NUM
		|
		(CharConst) CHAR
		|
		(BoolConst) BOOL
		;

Type ::= (Type) IDENT:typeName;